using System;
using System.Reflection;
using System.Text;
using PrepareLanding.Defs;
using PrepareLanding.Patches;
using UnityEngine;
using Verse;
using HarmonyLib;
using RimWorld;

namespace PrepareLanding
{
    public class RimWorldEventHandler
    {
        public RimWorldEventHandler()
        {
            /*
             * Initialize events from harmony patches.
             */
            PatchWorldInterfaceOnGui.WorldInterfaceOnGui += OnWorldInterfaceOnGui;
            PatchWorldInterfaceUpdate.WorldInterfaceUpdate += OnWorldInterfaceUpdate;

            PatchGenerateWorld.WorldAboutToBeGenerated += OnWordAboutToBeGenerated;
            PatchGenerateWorld.WorldGenerated += OnWorldGenerated;
        }

        /// <summary>
        ///     Classes can register to this event to be called when definitions (Defs) have been loaded.
        ///     Note that game settings are loaded alongside Defs!
        /// </summary>
        public event Action DefsLoaded = delegate { };

        /// <summary>
        ///     Classes can register to this event to be called when the world is about to be generated.
        /// </summary>
        /// <remarks>This is not a RimWorld event, it is generated by this mod from an Harmony patch.</remarks>
        public event Action WorldAboutToBeGenerated = delegate { };

        /// <summary>
        ///     Classes can register to this event to be called when the world has been generated.
        /// </summary>
        /// <remarks>This is not a RimWorld event, it is generated by this mod from an Harmony patch.</remarks>
        public event Action WorldGenerated = delegate { };

        /// <summary>
        ///     Called when GameState.Playing has been entered and the world is fully loaded in the Play scene.
        ///     Will not be called during world generation and landing site selection.
        /// </summary>
        public event Action WorldLoaded = delegate { };


        /// <summary>
        ///     Classes can register to this event to be called when the world has been generated and / or loaded.
        ///     Classes should not register to this event <b>and</b> WorldGenerated or WorldLoaded as they would receive the same event twice.
        /// </summary>
        public event Action WorldGeneratedOrLoaded = delegate { };

        /// <summary>
        ///     Classes can register to this event to be called when the OnGUI() method (while on the world map) is called.
        ///     See also <seealso cref="WorldInterfaceOnGui" />.
        /// </summary>
        public event Action WorldInterfaceOnGui = delegate { };

        /// <summary>
        ///     Classes can register to this event to be called when the Update() method (while on the world map) is called.
        ///     See also <seealso cref="WorldInterfaceUpdate" />.
        /// </summary>
        public event Action WorldInterfaceUpdate = delegate { };

        /// <summary>
        ///     Called when the world has been generated.
        /// </summary>
        private void OnWorldGenerated()
        {
            Log.Message("[PrepareLanding] OnWorldGenerated");

            // note: if we don't use ExecuteWhenFinished() then the world has been generated but the world field (from Find.World) is not yet set and is null.
            // so better use ExecuteWhenFinished as we are inside a LongEventHandler; see RimWorld.Page_CreateWorldParams.CanDoNext()
            LongEventHandler.ExecuteWhenFinished(delegate
            {
                WorldGenerated?.Invoke();
                WorldGeneratedOrLoaded?.Invoke();
            });
        }

        /// <summary>
        ///     Called when the world is about to be generated.
        /// </summary>
        private void OnWordAboutToBeGenerated()
        {
            Log.Message("[PrepareLanding] OnWordAboutToBeGenerated");
            WorldAboutToBeGenerated?.Invoke();
        }

        /// <summary>
        ///     Called when definitions (Defs) has been loaded.
        /// </summary>
        public void OnDefsLoaded()
        {
            Log.Message("[PrepareLanding] OnDefsLoaded");
            DefsLoaded?.Invoke();

            //
            // Try to patch Page_CreateWorldParams.CanDoNext
            // we need to do it here because the settings are only loaded at that time, and we need to check the
            // setting if we patch it or not. The verification is done in the patching method itself, not here.
            //

            var harmony = new Harmony("com.neitsa.preparelanding");
            var canDoNextOriginalMethod = typeof(Page_CreateWorldParams).GetMethod("CanDoNext", BindingFlags.Instance | BindingFlags.NonPublic);
            if (canDoNextOriginalMethod == null) {
                Log.Message("[PrepareLanding] Could not find Page_CreateWorldParams.CanDoNext.");
                return;
            }
            var patches = Harmony.GetPatchInfo(canDoNextOriginalMethod);
            if (patches is null) {
                // method is not patched!
                Log.Message("[PrepareLanding] Manual Patching: Page_CreateWorldParams_CanDoNext");
                var prefix = typeof(PatchCreateWorldParams).GetMethod("Page_CreateWorldParams_CanDoNext", BindingFlags.NonPublic | BindingFlags.Static);
                if (prefix is null) {
                    Log.Message("[PrepareLanding] Could not find PatchCreateWorldParams.Page_CreateWorldParams_CanDoNext prefix.");
                    return;
                }
                var replacementMethod = harmony.Patch(canDoNextOriginalMethod, new HarmonyMethod(prefix));
                Log.Message($"[PrepareLanding] PatchCreateWorldParams.Page_CreateWorldParams_CanDoNext - patch done: {!(replacementMethod is null)}");
            }
            else {
                // method is patched with a prefix... We can't add our own. Just log and bail out.
                Log.Message("[PrepareLanding] Page_CreateWorldParams.CanDoNext is already patched. Can't instantiate PreciseWorldGeneration...");
                StringBuilder sb = new StringBuilder();
                foreach (var patchesPrefix in patches.Prefixes)
                {
                    sb.Append($"index: {patchesPrefix.index}; ");
                    sb.Append($"owner: {patchesPrefix.owner}; ");
                    sb.Append($"patch method: {patchesPrefix.PatchMethod}; ");
                    sb.Append($"priority: {patchesPrefix.priority}; ");
                    sb.Append($"before: {patchesPrefix.before}; ");
                    sb.Append($"after: {patchesPrefix.after}");
                    sb.Append("\n----\n");
                }
                Log.Message(sb.ToString());
            }
        }

        /// <summary>
        ///     Called when a world is loaded. This happens only when a save file is loaded.
        /// </summary>
        public void OnWorldLoaded()
        {
            Log.Message("[PrepareLanding] OnWorldLoaded");
            WorldLoaded?.Invoke();
            WorldGeneratedOrLoaded?.Invoke();
        }

        /// <summary>
        ///     Called on each <see cref="RimWorld.WorldInterface" /> Gui event.
        /// </summary>
        private void OnWorldInterfaceOnGui()
        {
            //Log.Message("[PrepareLanding] OnWorldInterfaceOnGui");
            OnWorldInterfaceOnGuiPump();
            WorldInterfaceOnGui?.Invoke();
        }

        /// <summary>
        ///     Called on each <see cref="RimWorld.WorldInterface" /> update event.
        /// </summary>
        private void OnWorldInterfaceUpdate()
        {
            //Log.Message("[PrepareLanding] OnWorldInterfaceUpdate");
            WorldInterfaceUpdate?.Invoke();
        }

        /// <summary>
        ///     Handle key down events when the World interface is displayed.
        /// </summary>
        private void OnWorldInterfaceOnGuiPump()
        {
            if (Event.current.type != EventType.KeyDown)
                return;

            // coordinates window
            if (KeyBindings.CoordinatesWindow.JustPressed && KeysUtils.IsControlPressedAndHeld)
            {
                if (Coordinates.MainWindow.CanBeDisplayed && !Coordinates.MainWindow.IsInWindowStack)
                {
                    var coordinatesWindows = new Coordinates.MainWindow();
                    Find.WindowStack.Add(coordinatesWindows);
                }
            }

            // main window
            if (KeyBindings.PrepareLandingWindow.JustPressed && KeysUtils.IsControlPressedAndHeld)
            {
                // don't add a new window if the window is already there; if it's not create a new one.
                if (PrepareLanding.Instance.MainWindow == null)
                    PrepareLanding.Instance.MainWindow = new MainWindow(PrepareLanding.Instance.GameData);

                if (!Find.WindowStack.IsOpen(PrepareLanding.Instance.MainWindow))
                {
                    Find.WindowStack.Add(PrepareLanding.Instance.MainWindow);
                }
            }

        }
    }
}